<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Kubernetes综合实验 # 实验目的 # 了解Kubernetes的各种特性 掌握Kubernetes的常用功能 注意事项
本次分配的机器的账户和密码为： buaa: &shieshuyuan21 为了避免权限问题，建议切换到root账户操作：
首先使用sudo passwd root为root账户设置密码 然后使用sudo su命令切换到root账户 务必首先修改机器的root和buaa账户的密码
请务必阅读 虚拟机使用说明。
分配的虚拟机中，已经安装了Docker，无需重复安装。
背景 # 上学期的云计算课中，我们主要了解了什么是容器，以及目前最流行的容器运行时和容器管理工具Docker；并且在此过程中体会了容器技术给软件开发和部署带来的极大的便利性。
但到此为止，我们对容器的使用和管理依旧处于非常“手工”的状态，难以胜任实际生产环境中对容器管理的要求。在实际生产环境中，
通常一个应用包含多个容器；即，一个应用的部署，需要按照一定的顺序启动多个容器。例如，即便是一个最简单的前后端应用，我们也需要依次启动三个容器：数据库容器（例如一个MySQL容器）、后端应用容器、前端应用容器（通常是一个Nginx容器）。特别是在微服务场景中，后端可能涉及到几十个微服务模块，每个模块都对应着一个容器，不同服务之间又有复杂的依赖调用关系。 每个类别的服务通常会有多个容器实例。对于一些负载较高的服务，通常会部署多个相同的容器实例达到负载均衡的效果，从而提高服务整体的吞吐量。 容器是不稳定的，随时可能会因为各种各样的原因挂掉，因此，需要时刻监控容器的状态，在它挂掉的时候及时重新启动服务，保证服务整体的高可用。 大部分应用都是分布式的。即，一个应用中的不同服务是部署在不同机器上的，即使是一个服务的不同实例往往也会部署在多个机器上。如何在多台机器上做好资源（内存、CPU、磁盘）的负载均衡（即，避免出现某些机器负载过高的同时，其他机器负载空闲的情况）也是棘手的问题。 如果仅靠我们已经学到的几个docker命令显然是难以完成上述任务的。这就需要一个专门的容器编排调度工具帮我们处理这些事情。自Docker兴起后，很多厂商都进入该领域并推出了自己的容器编排调度解决方案，例如Docker Swarm、Mesos等，都想在新兴的容器市场中分一杯羹，但最终Kubernetes笑到了最后，并且作为CNCF的毕业项目，成为了当下容器编排调度领域的事实标准。本次实验我们就来认识一下Kubernetes，学习并实践其中一些基本概念。
Kubernetes以其复杂难懂著称，在本次实验中，我们主要学习其中最基本的部分，培养大家对Kubernetes的感性认识，帮助大家开始入门云计算领域。
初识Kubernetes # Kubernetes简介 # Kubernetes在希腊语中的含义是船长/领航员，这个名字生动地体现了它在容器集群管理中的作用——调度和监控全局的集装箱（container，容器）。由于Kubernetes这个单词太长，人们通常会用k8s来作为简称（Kubernetes的首尾两个字母之间正好有8个字母）。
请始终记住，Kubernetes和Docker之类的容器运行时不是互相替代的关系，也不是包含与被包含的关系，而是互补的关系。Kubernetes仅仅是一个容器编排和调度工具，其必须运行在“容器运行时（container runtime）”之上。它能做的仅仅是接收用户的命令，然后通知其下层的容器运行时做具体的工作。
上图可以看出，在之前，我们是直接通过Docker命令行或Docker HTTP接口来与Docker容器运行时通信，控制其构建镜像、推送或拉取镜像、启动或停止容器，等等。
而现在，我们可以通过Kubernetes的命令行工具（即Kubectl）或Kubernetes的HTTP接口来控制Kubernetes，然后，Kubernetes会根据我们发出的命令，“翻译”成对应的Docker容器运行时的调用，从而控制Docker容器运行时构建镜像、推送或拉取镜像、启动或停止容器等等。
另外，请注意，Kubernetes是一个非常模块化的系统，它定义了一套“容器运行时接口（CRI）”，凡是实现了这套接口的容器运行时都可以作为Kubernetes运行容器的后端。目前比较流行的有Containerd和CRI-O，实际上，从1.20版本开始，Kubernetes官方已经弃用Docker引擎作为容器运行时。
在本次实验中，为了前后知识的连贯性，我们依旧选择使用Docker作为Kubernetes的容器运行时。
创建Kubernetes集群 # 在Kubernetes官网的 Get Started中，分别给出了面向个人初学者的学习测试环境和一线生产环境的若干Kubernetes集群部署方法。对于生产环境， Kubernetes官方推荐使用kubeadm来启动集群。但实际上，kubeadm对非专业的运维，特别是初学者来说并不十分友好（需要用户事先完成对主机的一系列配置，如开放防火墙端口、关闭swap、安装容器运行时等），再加上国内特殊的网络环境（kubeadm默认会从gcr.io拉取启动Kubernetes所需的系统镜像），因此不推荐初学者直接使用kubeadm启动集群。
云计算生态非常繁荣，社区中已经有很多成熟的工具帮助用户快速启动一个标准的Kubernetes集群用于学习、测试等目的。本实验文档分别针对集群版和本地版提供创建Kubernetes集群的选项，供大家参考和使用。
集群版 # 推荐使用此种方式创建集群，这样有利于在后续章节中学习和实践Kubernetes“集群”的相关特性。如确实有问题，可以切换到个人电脑上使用“单机版”的方式。
在本次实验中，我们将部署一个简单的 k3s（注意，不是“k8s”哦！）集群。k3s是通过CNCF认证的Kubernetes的一个发行版，是基于上游的“原生”的Kubernetes的代码进一步构建的。k3s和Kubernetes的关系可以简单类比为Ubuntu、CentOS等于Linux之间的关系。你可以在这里找到k3s官方维护的 k3s的中文文档。
实际上，还有很多其他的Kubernetes发行版，比如k0s之类的。只不过k3s的中国化做得非常好，在国内的网络环境下使用非常便利，也有大量的资料可以使用，所以我们选用其作为本次实验的主要工具。当然，不同Kubernetes发行版之间存在着各种各样的差异，但这并不影响我们学习Kubernetes的基础知识。
准备一台能够连接互联网的Linux机器。如果你选择使用软院云平台分配的机器，可以直接进行下一步；否则，请查看 安装要求，确保你的机器满足其中所述条件。
确保机器已经安装Docker，并且其版本高于或等于19.03，可以使用docker info命令验证。如果你使用的是软院云平台分配的机器，可直接进行下一步；否则，请注意检查Docker是否正确安装，并且是否正确配置Docker Registry镜像地址，以保证可以顺利从docker.io中拉取镜像。（当然，如果你已经比较熟悉Kubernetes，可以忽略此步骤，选择使用k3s默认集成安装的containerd作为容器运行时。）
保证你的机器已经连接互联网。
切换到root用户（如果你觉得root操作危险，请保证自己有足够的能力使用普通用户权限完成所有操作），执行以下命令以初始化一个k3s的master节点（当前不理解什么是“master节点”没有关系，在后续章节中我们会进行详细介绍）：
curl -sfL https://rancher-mirror.oss-cn-beijing.aliyuncs.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -s - --docker 如果你选择使用containerd作为容器运行时，请去除上述命令中的--docker参数。"><meta name=theme-color content="#FFFFFF"><meta name=color-scheme content="light dark"><meta property="og:title" content="Kubernetes综合实验"><meta property="og:description" content="Kubernetes综合实验 # 实验目的 # 了解Kubernetes的各种特性 掌握Kubernetes的常用功能 注意事项
本次分配的机器的账户和密码为： buaa: &shieshuyuan21 为了避免权限问题，建议切换到root账户操作：
首先使用sudo passwd root为root账户设置密码 然后使用sudo su命令切换到root账户 务必首先修改机器的root和buaa账户的密码
请务必阅读 虚拟机使用说明。
分配的虚拟机中，已经安装了Docker，无需重复安装。
背景 # 上学期的云计算课中，我们主要了解了什么是容器，以及目前最流行的容器运行时和容器管理工具Docker；并且在此过程中体会了容器技术给软件开发和部署带来的极大的便利性。
但到此为止，我们对容器的使用和管理依旧处于非常“手工”的状态，难以胜任实际生产环境中对容器管理的要求。在实际生产环境中，
通常一个应用包含多个容器；即，一个应用的部署，需要按照一定的顺序启动多个容器。例如，即便是一个最简单的前后端应用，我们也需要依次启动三个容器：数据库容器（例如一个MySQL容器）、后端应用容器、前端应用容器（通常是一个Nginx容器）。特别是在微服务场景中，后端可能涉及到几十个微服务模块，每个模块都对应着一个容器，不同服务之间又有复杂的依赖调用关系。 每个类别的服务通常会有多个容器实例。对于一些负载较高的服务，通常会部署多个相同的容器实例达到负载均衡的效果，从而提高服务整体的吞吐量。 容器是不稳定的，随时可能会因为各种各样的原因挂掉，因此，需要时刻监控容器的状态，在它挂掉的时候及时重新启动服务，保证服务整体的高可用。 大部分应用都是分布式的。即，一个应用中的不同服务是部署在不同机器上的，即使是一个服务的不同实例往往也会部署在多个机器上。如何在多台机器上做好资源（内存、CPU、磁盘）的负载均衡（即，避免出现某些机器负载过高的同时，其他机器负载空闲的情况）也是棘手的问题。 如果仅靠我们已经学到的几个docker命令显然是难以完成上述任务的。这就需要一个专门的容器编排调度工具帮我们处理这些事情。自Docker兴起后，很多厂商都进入该领域并推出了自己的容器编排调度解决方案，例如Docker Swarm、Mesos等，都想在新兴的容器市场中分一杯羹，但最终Kubernetes笑到了最后，并且作为CNCF的毕业项目，成为了当下容器编排调度领域的事实标准。本次实验我们就来认识一下Kubernetes，学习并实践其中一些基本概念。
Kubernetes以其复杂难懂著称，在本次实验中，我们主要学习其中最基本的部分，培养大家对Kubernetes的感性认识，帮助大家开始入门云计算领域。
初识Kubernetes # Kubernetes简介 # Kubernetes在希腊语中的含义是船长/领航员，这个名字生动地体现了它在容器集群管理中的作用——调度和监控全局的集装箱（container，容器）。由于Kubernetes这个单词太长，人们通常会用k8s来作为简称（Kubernetes的首尾两个字母之间正好有8个字母）。
请始终记住，Kubernetes和Docker之类的容器运行时不是互相替代的关系，也不是包含与被包含的关系，而是互补的关系。Kubernetes仅仅是一个容器编排和调度工具，其必须运行在“容器运行时（container runtime）”之上。它能做的仅仅是接收用户的命令，然后通知其下层的容器运行时做具体的工作。
上图可以看出，在之前，我们是直接通过Docker命令行或Docker HTTP接口来与Docker容器运行时通信，控制其构建镜像、推送或拉取镜像、启动或停止容器，等等。
而现在，我们可以通过Kubernetes的命令行工具（即Kubectl）或Kubernetes的HTTP接口来控制Kubernetes，然后，Kubernetes会根据我们发出的命令，“翻译”成对应的Docker容器运行时的调用，从而控制Docker容器运行时构建镜像、推送或拉取镜像、启动或停止容器等等。
另外，请注意，Kubernetes是一个非常模块化的系统，它定义了一套“容器运行时接口（CRI）”，凡是实现了这套接口的容器运行时都可以作为Kubernetes运行容器的后端。目前比较流行的有Containerd和CRI-O，实际上，从1.20版本开始，Kubernetes官方已经弃用Docker引擎作为容器运行时。
在本次实验中，为了前后知识的连贯性，我们依旧选择使用Docker作为Kubernetes的容器运行时。
创建Kubernetes集群 # 在Kubernetes官网的 Get Started中，分别给出了面向个人初学者的学习测试环境和一线生产环境的若干Kubernetes集群部署方法。对于生产环境， Kubernetes官方推荐使用kubeadm来启动集群。但实际上，kubeadm对非专业的运维，特别是初学者来说并不十分友好（需要用户事先完成对主机的一系列配置，如开放防火墙端口、关闭swap、安装容器运行时等），再加上国内特殊的网络环境（kubeadm默认会从gcr.io拉取启动Kubernetes所需的系统镜像），因此不推荐初学者直接使用kubeadm启动集群。
云计算生态非常繁荣，社区中已经有很多成熟的工具帮助用户快速启动一个标准的Kubernetes集群用于学习、测试等目的。本实验文档分别针对集群版和本地版提供创建Kubernetes集群的选项，供大家参考和使用。
集群版 # 推荐使用此种方式创建集群，这样有利于在后续章节中学习和实践Kubernetes“集群”的相关特性。如确实有问题，可以切换到个人电脑上使用“单机版”的方式。
在本次实验中，我们将部署一个简单的 k3s（注意，不是“k8s”哦！）集群。k3s是通过CNCF认证的Kubernetes的一个发行版，是基于上游的“原生”的Kubernetes的代码进一步构建的。k3s和Kubernetes的关系可以简单类比为Ubuntu、CentOS等于Linux之间的关系。你可以在这里找到k3s官方维护的 k3s的中文文档。
实际上，还有很多其他的Kubernetes发行版，比如k0s之类的。只不过k3s的中国化做得非常好，在国内的网络环境下使用非常便利，也有大量的资料可以使用，所以我们选用其作为本次实验的主要工具。当然，不同Kubernetes发行版之间存在着各种各样的差异，但这并不影响我们学习Kubernetes的基础知识。
准备一台能够连接互联网的Linux机器。如果你选择使用软院云平台分配的机器，可以直接进行下一步；否则，请查看 安装要求，确保你的机器满足其中所述条件。
确保机器已经安装Docker，并且其版本高于或等于19.03，可以使用docker info命令验证。如果你使用的是软院云平台分配的机器，可直接进行下一步；否则，请注意检查Docker是否正确安装，并且是否正确配置Docker Registry镜像地址，以保证可以顺利从docker.io中拉取镜像。（当然，如果你已经比较熟悉Kubernetes，可以忽略此步骤，选择使用k3s默认集成安装的containerd作为容器运行时。）
保证你的机器已经连接互联网。
切换到root用户（如果你觉得root操作危险，请保证自己有足够的能力使用普通用户权限完成所有操作），执行以下命令以初始化一个k3s的master节点（当前不理解什么是“master节点”没有关系，在后续章节中我们会进行详细介绍）：
curl -sfL https://rancher-mirror.oss-cn-beijing.aliyuncs.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh -s - --docker 如果你选择使用containerd作为容器运行时，请去除上述命令中的--docker参数。"><meta property="og:type" content="article"><meta property="og:url" content="https://scs.buaa.edu.cn/doc/cloud-labs/cloud/kube-single-3/"><meta property="article:section" content="cloud-labs"><meta property="article:modified_time" content="2022-10-29T21:16:23+08:00"><title>Kubernetes综合实验 | 软院云平台文档</title><link rel=manifest href=/doc/manifest.json><link rel=icon href=/doc/favicon.png type=image/x-icon><link rel=stylesheet href=/doc/book.min.46181bc93375ba932026e753b37c40e6ff8bb16a9ef770c78bcc663e4577b1ba.css integrity="sha256-RhgbyTN1upMgJudTs3xA5v+LsWqe93DHi8xmPkV3sbo=" crossorigin=anonymous><script defer src=/doc/flexsearch.min.js></script>
<script defer src=/doc/en.search.min.d85a5bf36f4a5517a694095db8e8f45d68d069cf12b7ce04ccd34e8d777e402c.js integrity="sha256-2Fpb829KVRemlAlduOj0XWjQac8St84EzNNOjXd+QCw=" crossorigin=anonymous></script>
<script defer src=/doc/sw.min.c6e13cf2801d746c82b18aace5ed50254554a6ab28bdd01a6fd9fdc0d082e427.js integrity="sha256-xuE88oAddGyCsYqs5e1QJUVUpqsovdAab9n9wNCC5Cc=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/doc/><span>软院云平台文档</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=https://scs.buaa.edu.cn/doc/02_bugit/>BuGit代码托管与自动部署平台</a><ul><li><a href=https://scs.buaa.edu.cn/doc/02_bugit/build_deploy/>自动构建与部署</a></li></ul></li><li><a href=https://scs.buaa.edu.cn/doc/01_common/>云平台使用手册</a><ul><li><a href=https://scs.buaa.edu.cn/doc/01_common/virtual_machine_help/>虚拟机使用说明</a></li></ul></li><li><a href=https://scs.buaa.edu.cn/doc/cloud-labs/>大数据和云计算综合实践</a><ul><li><a href=https://scs.buaa.edu.cn/doc/cloud-labs/cloud/>云计算实验</a><ul><li><a href=https://scs.buaa.edu.cn/doc/cloud-labs/cloud/container_docker/>容器与Docker综合实验</a></li><li><a href=https://scs.buaa.edu.cn/doc/cloud-labs/cloud/cloud_course_design/>云计算课程设计</a></li><li><a href=https://scs.buaa.edu.cn/doc/cloud-labs/cloud/kube-single-3/ class=active>Kubernetes综合实验</a></li><li><a href=https://scs.buaa.edu.cn/doc/cloud-labs/cloud/faq/>FAQ</a></li></ul></li></ul></li><li><a href=https://scs.buaa.edu.cn/doc/ns-labs/>网络存储实验规划</a><ul><li><a href=https://scs.buaa.edu.cn/doc/ns-labs/table-of-contents/>Table of Contents</a><ul><li><a href=https://scs.buaa.edu.cn/doc/ns-labs/table-of-contents/raid/>Lab01 RAID 阵列</a></li><li><a href=https://scs.buaa.edu.cn/doc/ns-labs/table-of-contents/virtualization/>Lab02 虚拟化实验</a></li><li><a href=https://scs.buaa.edu.cn/doc/ns-labs/table-of-contents/ceph/>Lab03 Ceph存储集群实践</a></li></ul></li><li><a href=https://scs.buaa.edu.cn/doc/ns-labs/resources/>Resources</a><ul><li><a href=https://scs.buaa.edu.cn/doc/ns-labs/resources/os/>操作系统</a></li></ul></li></ul></li></ul><ul><li><a href=https://github.com/bugitt/doc target=_blank rel=noopener>Github</a></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/doc/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Kubernetes综合实验</strong>
<label for=toc-control><img src=/doc/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#kubernetes综合实验>Kubernetes综合实验</a><ul><li><a href=#实验目的>实验目的</a></li><li><a href=#背景>背景</a></li><li><a href=#初识kubernetes>初识Kubernetes</a><ul><li><a href=#kubernetes简介>Kubernetes简介</a></li><li><a href=#创建kubernetes集群>创建Kubernetes集群</a></li><li><a href=#使用kubernetes启动第一个容器>使用Kubernetes启动第一个容器</a></li></ul></li><li><a href=#pod>Pod</a><ul><li><a href=#查看pod>查看Pod</a></li><li><a href=#删除pod>删除Pod</a></li><li><a href=#pod的生命周期>Pod的生命周期</a></li><li><a href=#使用yaml文件管理pod>使用YAML文件管理Pod</a></li></ul></li><li><a href=#label>Label</a></li><li><a href=#pod-controller>Pod Controller</a><ul><li><a href=#controller>Controller</a></li><li><a href=#pod-controller-1>Pod Controller</a></li><li><a href=#deployment>Deployment</a></li><li><a href=#其他pod-controller>其他Pod Controller</a></li></ul></li><li><a href=#service>Service</a><ul><li><a href=#创建service>创建Service</a></li><li><a href=#暴露端口>暴露端口</a></li></ul></li><li><a href=#基于云的课程设计二选一>基于云的课程设计（二选一）</a><ul><li><a href=#选项一云paas平台设计>选项一：云PaaS平台设计</a></li><li><a href=#选项二数据分析开发环境迁移上云>选项二：“数据分析开发环境”迁移上云</a></li></ul></li></ul></li></ul></nav></aside></header><article class=markdown><h1 id=kubernetes综合实验>Kubernetes综合实验
<a class=anchor href=#kubernetes%e7%bb%bc%e5%90%88%e5%ae%9e%e9%aa%8c>#</a></h1><h2 id=实验目的>实验目的
<a class=anchor href=#%e5%ae%9e%e9%aa%8c%e7%9b%ae%e7%9a%84>#</a></h2><ul><li>了解Kubernetes的各种特性</li><li>掌握Kubernetes的常用功能</li></ul><blockquote class="book-hint danger"><p><strong>注意事项</strong></p><ol><li>本次分配的机器的账户和密码为：</li></ol><pre tabindex=0><code>buaa: &amp;shieshuyuan21
</code></pre><p>为了避免权限问题，建议切换到root账户操作：</p><ul><li>首先使用<code>sudo passwd root</code>为root账户设置密码</li><li>然后使用<code>sudo su</code>命令切换到root账户</li></ul><p><strong>务必首先修改机器的root和buaa账户的密码</strong></p><ol start=2><li><p>请务必阅读
<a href=../..//01_common/virtual_machine_help.md>虚拟机使用说明</a>。</p></li><li><p>分配的虚拟机中，已经安装了Docker，无需重复安装。</p></li></ol></blockquote><h2 id=背景>背景
<a class=anchor href=#%e8%83%8c%e6%99%af>#</a></h2><p>上学期的云计算课中，我们主要了解了什么是容器，以及目前最流行的容器运行时和容器管理工具Docker；并且在此过程中体会了容器技术给软件开发和部署带来的极大的便利性。</p><p>但到此为止，我们对容器的使用和管理依旧处于非常“手工”的状态，难以胜任实际生产环境中对容器管理的要求。在实际生产环境中，</p><ol><li>通常一个应用包含多个容器；即，一个应用的部署，需要按照一定的顺序启动多个容器。例如，即便是一个最简单的前后端应用，我们也需要<strong>依次</strong>启动三个容器：数据库容器（例如一个MySQL容器）、后端应用容器、前端应用容器（通常是一个Nginx容器）。特别是在微服务场景中，后端可能涉及到几十个微服务模块，每个模块都对应着一个容器，不同服务之间又有复杂的依赖调用关系。</li><li>每个类别的服务通常会有多个容器实例。对于一些负载较高的服务，通常会部署多个相同的容器实例达到负载均衡的效果，从而提高服务整体的吞吐量。</li><li>容器是不稳定的，随时可能会因为各种各样的原因挂掉，因此，需要时刻监控容器的状态，在它挂掉的时候及时重新启动服务，保证服务整体的高可用。</li><li>大部分应用都是分布式的。即，一个应用中的不同服务是部署在不同机器上的，即使是一个服务的不同实例往往也会部署在多个机器上。如何在多台机器上做好资源（内存、CPU、磁盘）的负载均衡（即，避免出现某些机器负载过高的同时，其他机器负载空闲的情况）也是棘手的问题。</li></ol><p>如果仅靠我们已经学到的几个docker命令显然是难以完成上述任务的。这就需要一个专门的容器编排调度工具帮我们处理这些事情。自Docker兴起后，很多厂商都进入该领域并推出了自己的容器编排调度解决方案，例如Docker Swarm、Mesos等，都想在新兴的容器市场中分一杯羹，但最终Kubernetes笑到了最后，并且作为CNCF的毕业项目，成为了当下容器编排调度领域的事实标准。本次实验我们就来认识一下Kubernetes，学习并实践其中一些基本概念。</p><p><img src=download/VI8sKsx.jpg alt></p><p>Kubernetes以其复杂难懂著称，在本次实验中，我们主要学习其中最基本的部分，培养大家对Kubernetes的感性认识，帮助大家开始入门云计算领域。</p><p><img src=download/HtGSlKi.png alt></p><h2 id=初识kubernetes>初识Kubernetes
<a class=anchor href=#%e5%88%9d%e8%af%86kubernetes>#</a></h2><h3 id=kubernetes简介>Kubernetes简介
<a class=anchor href=#kubernetes%e7%ae%80%e4%bb%8b>#</a></h3><p>Kubernetes在希腊语中的含义是船长/领航员，这个名字生动地体现了它在容器集群管理中的作用——调度和监控全局的集装箱（container，容器）。由于Kubernetes这个单词太长，人们通常会用k8s来作为简称（Kubernetes的首尾两个字母之间正好有8个字母）。</p><p>请始终记住，Kubernetes和Docker之类的容器运行时不是互相替代的关系，也不是包含与被包含的关系，而是互补的关系。Kubernetes仅仅是一个容器编排和调度工具，其必须运行在“容器运行时（container runtime）”之上。它能做的仅仅是接收用户的命令，然后通知其下层的容器运行时做具体的工作。</p><p><img src=download/a0rNhUd.png alt></p><p>上图可以看出，在之前，我们是直接通过Docker命令行或Docker HTTP接口来与Docker容器运行时通信，控制其构建镜像、推送或拉取镜像、启动或停止容器，等等。</p><p>而现在，我们可以通过Kubernetes的命令行工具（即Kubectl）或Kubernetes的HTTP接口来控制Kubernetes，然后，Kubernetes会根据我们发出的命令，“翻译”成对应的Docker容器运行时的调用，从而控制Docker容器运行时构建镜像、推送或拉取镜像、启动或停止容器等等。</p><p>另外，请注意，Kubernetes是一个非常模块化的系统，它定义了一套“容器运行时接口（CRI）”，凡是实现了这套接口的容器运行时都可以作为Kubernetes运行容器的后端。目前比较流行的有Containerd和CRI-O，实际上，从1.20版本开始，Kubernetes官方已经弃用Docker引擎作为容器运行时。</p><p><img src=download/KBTozW2.png alt></p><blockquote><p>在本次实验中，为了前后知识的连贯性，我们依旧选择使用Docker作为Kubernetes的容器运行时。</p></blockquote><h3 id=创建kubernetes集群>创建Kubernetes集群
<a class=anchor href=#%e5%88%9b%e5%bb%bakubernetes%e9%9b%86%e7%be%a4>#</a></h3><p>在Kubernetes官网的
<a href=https://kubernetes.io/docs/setup/>Get Started</a>中，分别给出了面向个人初学者的学习测试环境和一线生产环境的若干Kubernetes集群部署方法。对于生产环境，
<a href=https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/>Kubernetes官方推荐使用<code>kubeadm</code>来启动集群</a>。但实际上，<code>kubeadm</code>对非专业的运维，特别是初学者来说并不十分友好（需要用户事先完成对主机的一系列配置，如开放防火墙端口、关闭swap、安装容器运行时等），再加上国内特殊的网络环境（<code>kubeadm</code>默认会从<code>gcr.io</code>拉取启动Kubernetes所需的系统镜像），因此不推荐初学者直接使用<code>kubeadm</code>启动集群。</p><p><img src=download/Cr1awaZ.png alt></p><p>云计算生态非常繁荣，社区中已经有很多成熟的工具帮助用户快速启动一个标准的Kubernetes集群用于学习、测试等目的。本实验文档分别针对集群版和本地版提供创建Kubernetes集群的选项，供大家参考和使用。</p><h4 id=集群版>集群版
<a class=anchor href=#%e9%9b%86%e7%be%a4%e7%89%88>#</a></h4><p><strong>推荐使用此种方式创建集群</strong>，这样有利于在后续章节中学习和实践Kubernetes“集群”的相关特性。如确实有问题，可以切换到个人电脑上使用“单机版”的方式。</p><p>在本次实验中，我们将部署一个简单的
<a href=https://k3s.io>k3s</a>（注意，不是“k8s”哦！）集群。k3s是通过CNCF认证的Kubernetes的一个发行版，是基于上游的“原生”的Kubernetes的代码进一步构建的。k3s和Kubernetes的关系可以简单类比为Ubuntu、CentOS等于Linux之间的关系。你可以在这里找到k3s官方维护的
<a href=https://docs.rancher.cn/k3s/>k3s的中文文档</a>。</p><blockquote><p>实际上，还有很多其他的Kubernetes发行版，比如k0s之类的。只不过k3s的中国化做得非常好，在国内的网络环境下使用非常便利，也有大量的资料可以使用，所以我们选用其作为本次实验的主要工具。当然，不同Kubernetes发行版之间存在着各种各样的差异，但这并不影响我们学习Kubernetes的基础知识。</p></blockquote><ol><li><p>准备一台能够连接互联网的Linux机器。如果你选择使用软院云平台分配的机器，可以直接进行下一步；否则，请查看
<a href=https://docs.rancher.cn/docs/k3s/installation/installation-requirements/_index/>安装要求</a>，确保你的机器满足其中所述条件。</p></li><li><p>确保机器已经安装Docker，并且其版本高于或等于<code>19.03</code>，可以使用<code>docker info</code>命令验证。如果你使用的是软院云平台分配的机器，可直接进行下一步；否则，请注意检查Docker是否正确安装，并且是否正确配置Docker Registry镜像地址，以保证可以顺利从<code>docker.io</code>中拉取镜像。（当然，如果你已经比较熟悉Kubernetes，可以忽略此步骤，选择使用k3s默认集成安装的containerd作为容器运行时。）</p></li><li><p>保证你的机器已经连接互联网。</p></li><li><p><strong>切换到root用户</strong>（如果你觉得root操作危险，请保证自己有足够的能力使用普通用户权限完成所有操作），执行以下命令以初始化一个k3s的master节点（当前不理解什么是“master节点”没有关系，在后续章节中我们会进行详细介绍）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl -sfL https://rancher-mirror.oss-cn-beijing.aliyuncs.com/k3s/k3s-install.sh | INSTALL_K3S_MIRROR<span style=color:#f92672>=</span>cn sh -s - --docker
</span></span></code></pre></div><p>如果你选择使用containerd作为容器运行时，请去除上述命令中的<code>--docker</code>参数。</p></li><li><p>等待上述命令执行结束后，实际上我们的k3s已经安装完成，即，我们已经得到了一个可用的Kubernetes集群。在继续后续操作前，我们先完善一下配置：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>echo <span style=color:#e6db74>&#39;export KUBECONFIG=/etc/rancher/k3s/k3s.yaml&#39;</span> &gt;&gt; ~/.bashrc
</span></span><span style=display:flex><span>source ~/.bashrc
</span></span></code></pre></div><p>注意，如果你使用的不是bash，请注意更改上述命令。</p></li><li><p>使用<code>kubectl get node</code>验证一下Kubernetes集群是否就绪，一般可以得到如下结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>NAME     STATUS   ROLES                  AGE    VERSION
</span></span><span style=display:flex><span>debian   Ready    control-plane,master   2d1h   v1.24.4+k3s1
</span></span></code></pre></div><p><code>kubectl get node</code>这条命令是自解释的，含义是，获取当前Kubernetes集群中的所有节点信息。可以看到，当前我们这个Kubernetes集群中，仅有一个节点，并且：</p><ul><li>其名字（<code>NAME</code>）是<code>debian</code>（这个名字一般是当前机器的hostname）；</li><li>其状态（<code>STATUS</code>）是<code>Ready</code>（<code>Ready</code>表示节点状态健康，如果你刚刚完成集群创建，这里的状态显示可能是<code>Not Ready</code>，不要着急，等一会儿再看看）；</li><li>其在Kubernetes集群中的角色（<code>ROLES</code>）是<code>control-plane,master</code>，即两个角色：控制面（<code>control-plane</code>）、master；</li><li>其加入当前Kubernetes集群的时间（<code>AGE</code>）是2天1小时（<code>2d1h</code>）前；</li><li>其当前运行的Kubernetes版本号（<code>VERSION</code>）是<code>v1.24.4+k3s1</code>。</li></ul></li></ol><p>到目前为止，我们已经得到了一个可用的Kubernetes集群。但我们注意到，当前该集群中，仅包含一个节点，并且该节点的角色为<code>control-plane,master</code>。在实际生产环境中，很少会有这样的场景，但这对我们完成一些基础的学习和实践任务是完全足够的。如果你想拓展自己的这个单节点集群为真正的生产可用的多节点集群，可以参考
<a href=https://docs.rancher.cn/docs/k3s/installation/ha-embedded/_index>k3s的文档</a>。</p><h4 id=本地版>本地版
<a class=anchor href=#%e6%9c%ac%e5%9c%b0%e7%89%88>#</a></h4><p>Kubernetes集群从一开始就是为大规模的生产环境准备的（其最早就起源于Google内部的Borg），因此，我们推荐在本实验中使用集群版的方法创建集群。</p><p>但实际上在很多场景中，我们并不关心Kubernetes的多节点特性，而更关心如何快速在本地机器上启动一个Kubernetes集群用于简单的学习和测试目的。在这里，我们使用
<a href=https://minikube.sigs.k8s.io/docs/>minikube</a>介绍如何在你 <strong>本地的电脑（Windows或macOS）</strong> 中启动一个简单的Kubernetes集群。</p><blockquote><p>从名字上可以看出minikube表示“mini kubernetes”。</p></blockquote><blockquote><p>需要提前说明的是，minikube本质上是在你的Windows或macOS上启动了一个虚拟机，并在这个虚拟机中配置了Kubernetes的相关组件。因此，minikube用起来不会和k3s那样“直接”，在需要的时候，请及时查阅
<a href=https://minikube.sigs.k8s.io/docs/>其文档</a>。</p></blockquote><p>本节内容只能保证你能成功启动一个minikube实例，如果你需要进一步的个性化配置，请参考
<a href=https://minikube.sigs.k8s.io/docs/start/>安装文档</a>。</p><p>理论上，minkube的安装非常简单，按照其官方文档的介绍进行即可。但由于众所周知的网络问题，我们这里对官方文档的步骤进行了一些修改。</p><ol><li><p>确保已经安装Docker，并且自己的计算机已经联网。</p></li><li><p>安装minikube二进制文件。请进入
<a href=https://minikube.sigs.k8s.io/docs/start/>这个地址</a>，进入“Installation”一节，选择自己合适的选型，按照提示，进行下载和安装。完成该步骤后，无需进行该网页中的后续步骤，请回到本文档。
<img src=download/qiMEbTT.png alt></p></li><li><p>使用minikube启动一个Kubernetes集群（注意根据自己电脑配置的实际情况调整命令中<code>--cpus</code>和<code>--memory</code>的值）：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>minikube start --driver<span style=color:#f92672>=</span>docker --cpus<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span> --memory<span style=color:#f92672>=</span>4096mb --registry-mirror<span style=color:#f92672>=</span>https://mirror.baidubce.com --image-repository<span style=color:#f92672>=</span>registry.cn-hangzhou.aliyuncs.com/google_containers
</span></span></code></pre></div><p>然后，你大概会得到如下的输出：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>😄  Darwin 13.0 上的 minikube v1.26.1
</span></span><span style=display:flex><span>✨  根据用户配置使用 docker 驱动程序
</span></span><span style=display:flex><span>✅  正在使用镜像存储库 registry.cn-hangzhou.aliyuncs.com/google_containers
</span></span><span style=display:flex><span>📌  Using Docker Desktop driver with root privileges
</span></span><span style=display:flex><span>👍  Starting control plane node minikube in cluster minikube
</span></span><span style=display:flex><span>🚜  Pulling base image ...
</span></span><span style=display:flex><span>🔥  Creating docker container (CPUs=4, Memory=4096MB) ...
</span></span><span style=display:flex><span>🐳  正在 Docker 20.10.17 中准备 Kubernetes v1.24.3…
</span></span><span style=display:flex><span>🔎  Verifying Kubernetes components...
</span></span><span style=display:flex><span>    ▪ Using image registry.cn-hangzhou.aliyuncs.com/google_containers/storage-provisioner:v5
</span></span><span style=display:flex><span>🌟  Enabled addons: default-storageclass, storage-provisioner
</span></span><span style=display:flex><span>🏄  Done! kubectl is now configured to use &#34;minikube&#34; cluster and &#34;default&#34; namespace by default
</span></span></code></pre></div><p>从输出信息可以看出，我们的Kubernetes集群已经成功在我们自己的电脑上启动好了。</p></li><li><p>集群启动完成后，我们该如何访问集群呢？在k3s部分的介绍中，我们使用的是<code>kubectl</code>这个工具（还记得那个<code>kubectl get nodes</code>命令吗？）k3s在安装的时候默认会安装<code>kubectl</code>，minikube也会自动下载<code>kubectl</code>这个工具，但使用起来比较麻烦。因此，我们推荐手动安装一下<code>kubectl</code>。具体安装方法在
<a href=https://kubernetes.io/docs/tasks/tools/#kubectl>Kubernetes的文档</a>中写得非常详细，按照其说明自行安装即可，此处不再赘述。
<img src=download/icq8sSN.png alt></p></li><li><p>最后，我们还是使用<code>kubectl get node</code>来验证集群的安装情况：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>$ kubectl get node
</span></span><span style=display:flex><span>NAME       STATUS   ROLES           AGE   VERSION
</span></span><span style=display:flex><span>minikube   Ready    control-plane   22h   v1.24.3
</span></span></code></pre></div></li></ol><h3 id=使用kubernetes启动第一个容器>使用Kubernetes启动第一个容器
<a class=anchor href=#%e4%bd%bf%e7%94%a8kubernetes%e5%90%af%e5%8a%a8%e7%ac%ac%e4%b8%80%e4%b8%aa%e5%ae%b9%e5%99%a8>#</a></h3><p>前面提到，Kubernetes最大的作用就是用来“管理容器”。因此，我们的第一个Kubernetes操作就从“创建一个容器”开始。</p><p>执行：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl run first-container --image<span style=color:#f92672>=</span>docker.io/library/nginx --port<span style=color:#f92672>=</span><span style=color:#ae81ff>80</span>
</span></span></code></pre></div><p>上述命令是自解释的，表示使用<code>kubectl</code>创建一个名为<code>first-contaier</code>的容器，创建该容器使用的镜像是<code>docker.io/library/nginx</code>，并在创建完容器后，暴露出容器的<code>80</code>端口。</p><blockquote><p>上述的“创建一个名为<code>first-contaier</code>的容器”的表述并不准确，后面会详细解释。</p></blockquote><p><img src=download/rBIa9W3.png alt></p><p>执行完上述命令后，我们可以接着使用<code>kubectl get pod</code>查看当前所创建的容器的状态：</p><p><img src=download/VEsL5y2.png alt></p><p>可以看到，当前这个<code>fist-container</code>的<code>STATUS</code>是<code>ContainerCreating</code>，表示容器正在被创建。稍等一会儿我们再看一下：</p><p><img src=download/yXQkeUH.png alt></p><p>此时容器的<code>STATUS</code>是<code>Running</code>，表示容器已经成功运行了。</p><p>前面我们还提到，Kubernetes并不会替代Docker容器运行时的工作，而只是作为一个管理者在上层存在。那么，我们刚才创建的这个<code>first-contaienr</code>本质上应该是Docker容器运行时“代劳”的，那么我们应该可以使用<code>docker ps</code>看到刚才的创建的容器。事实也确实如此。</p><p><img src=download/BH1XR8y.png alt></p><p>我们再来对比一下使用Kubernetes创建容器和使用Docker创建容器的异同：</p><p><img src=download/RFXpJ1p.png alt></p><p>至此，想必大家已经对Kubernetes有了非常朴素的初步认知，接下来就让我们深入了解一下Kubernetes的一些基础概念。</p><h2 id=pod>Pod
<a class=anchor href=#pod>#</a></h2><p>想必细心的同学已经发现了，前面在使用<code>kubectl run</code>创建容器的时候，命令返回的提示信息是<code>pod/first-container created</code>：</p><p><img src=download/qWgiOVm.png alt></p><p>意思是，一个名为<code>first-container</code>的pod被创建了。我们创建的不是容器吗？这个“pod”是什么东西？</p><p>Pod是Kubernetes中的基本执行单元，即管理、创建、计划的最小单元（而不是<strong>容器</strong>）。一个Pod中可以包含多个容器，可以把Pod理解为“容器组”。在英文中，pod的意思是“豆荚”，豆荚中一般会包含多个豆子，豆荚和豆子的关系就类似于Pod和容器的关系。Pod内的各个容器共享网络和存储。比如可以使用localhost互相通信。</p><p><img src=download/XVqHtBc.png alt></p><p>在上一小节的“使用Kubernetes启动第一个容器”中，我们实际上是创建了一个名为“first-container”的Pod，这个Pod中包含了一个Nginx Container，而这个container，恰恰是我们使用<code>docker ps</code>看到的那个容器。</p><p><img src=download/5x1MNrv.jpg alt></p><h3 id=查看pod>查看Pod
<a class=anchor href=#%e6%9f%a5%e7%9c%8bpod>#</a></h3><p>Kubernetes的接口非常<code>Restful</code>，即对其进行的任何操作都可以归结为对各种资源的增删改查。因此，当我们想查看当前集群中的Pod时，只需要使用<code>get</code>方法<code>kubectl get pod</code>：</p><p><img src=download/a4zywa8.png alt></p><p>如果你已经知道了自己要查看的Pod名字，可以直接指定名称，例如<code>kubectl get pod first-container</code>：</p><p><img src=download/jYeie75.png alt></p><p>可以使用<code>-o wide</code>参数查看Pod更详细的内容：</p><p><img src=download/4H1HkQ4.png alt></p><p>可以看到，上述命令的输出中，包含了Pod的IP，这个IP是我们访问容器的重要工具。由于我们在<code>first-container</code>中启动的是一个Nginx Container，并且暴露了80端口，因此，可以通过该IP的80端口访问到Nginx Container：</p><p><img src=download/47u2p6X.png alt></p><h3 id=删除pod>删除Pod
<a class=anchor href=#%e5%88%a0%e9%99%a4pod>#</a></h3><p>删除Pod很简单：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-txt data-lang=txt><span style=display:flex><span>$ kubectl delete pod first-container
</span></span><span style=display:flex><span>pod &#34;first-container&#34; deleted
</span></span></code></pre></div><h3 id=pod的生命周期>Pod的生命周期
<a class=anchor href=#pod%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f>#</a></h3><p><code>kubectl get pod</code>中使用<code>--watch</code>参数可以监控集群中Pod的变化。接下来，我们通过使用<code>--watch</code>参数来学习Pod的生命周期。</p><p>首先打开两个终端窗口。在其中一个终端中，输入<code>kubectl get pod --watch</code>。该命令不会立即返回，而是会持续一段时间，在此过程中，集群中Pod发生的变化都会在该终端中输出：</p><p><img src=download/xn2ZmU5.png alt></p><p>然后，我们在另一个终端窗口中，依次执行Pod的创建操作：</p><p><img src=download/jPqQn7s.png alt></p><p>耐心等待一会儿，注意观察左侧终端窗口的变化。可以发现，名为<code>first-container</code>的Pod被创建，其状态</p><ol><li>最开始是<code>Pending</code>，表示Pod已经被Kubernetes系统接受，正在等待被创建。</li><li>然后<code>ContainerCreating</code>，表示Pod中的容器正在被创建中，这个过程可能会从网络拉取镜像，所以可能花费较长时间，特别是网络状态不好的时候。</li><li>最后是<code>Running</code>，并且其状态将最终停留在<code>Running</code>。当Pod状态为<code>Running</code>时，说明其已经被成功创建并正常运行了。</li></ol><p>下面，我们在右侧的终端窗口中，删除刚创建的Pod：</p><p><img src=download/MAmv5Gt.png alt></p><p>可以看到，Pod的状态变成了<code>Terminating</code>（中止），并最终不再变化（被删除了）。</p><h3 id=使用yaml文件管理pod>使用YAML文件管理Pod
<a class=anchor href=#%e4%bd%bf%e7%94%a8yaml%e6%96%87%e4%bb%b6%e7%ae%a1%e7%90%86pod>#</a></h3><p>通畅情况下，我们不会直接使用<code>kubectl run</code>这样的命令行来管理容器，而是使用一个
<a href=https://yaml.org/>YAML格式</a>的文件来描述Pod。比如，下面是一个典型的Pod的YAML描述：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-yaml</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.14.2</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
</span></span></code></pre></div><p><a href=https://yaml.org/>YAML格式</a>和JSON、XML一样，是一种用于配置描述语言（简单来说就是这种语言一般用来写配置文件）。YAML的语法非常简单，基本由KV键值对组成，并且使用缩进来表示嵌套关系。下面，我们就来详细说明一下上述这个Pod的YAML文件中各个字段的含义。</p><ul><li><code>apiVersion: v1</code>表示该Pod描述适用的Kubernetes的Pod的API版本是v1（如果不理解也问题不大，不影响后续的学习）</li><li><code>kind: Pod</code>表示当前这个YAML描述，描述的对象是一个Pod</li><li><code>metadata</code>表示“元信息”，一般会在这里描述Pod的名字、命名空间等“身份识别信息”。注意，<code>metadata</code>后面没有值，而且第二行缩进，表示<code>metadata</code>的值是一个对象，这个对象包含下面缩进中的若个键值对<ul><li><code>name: nginx-yaml</code>表示，该Pod的名字是<code>nginx-yaml</code>。它位于<code>metadata</code>的缩进中，表示其是<code>metadata</code>的值的一部分。</li></ul></li><li><code>spec</code>是对Pod的具体描述<ul><li><code>containers</code>描述了Pod中会包含哪些容器。可以看到，其第二行的<code>- name: nginx</code>是以<code>- </code>开头的，这说明，containers的值是一个数组，这个数组中的每个元素都是一个对象，这个对象包含了<code>name</code>、<code>image</code>、<code>ports</code>等键值对<ul><li><code>name: nginx</code>表示容器的名字是<code>nginx</code>。这个名字其实没有特殊含义，符合命名规范的情况下，随便写就行</li><li><code>image: nginx:1.14.2</code>表示这个容器使用的镜像是<code>nginx:1.14.2</code></li><li><code>ports</code>表示容器会向外暴露哪些端口</li></ul></li></ul></li></ul><p>将上述Pod的YAML描述保存到一个YAML文件中，如<code>pod-demo.yaml</code>，然后执行<code>kubectl apply -f pod-demo.yaml</code>，即可将该Pod<code>apply</code>到Kubernetes集群中。</p><p><code>apply</code>的含义是，</p><ul><li>如果当前集群中不存在存在文件中对描述的资源，那将创建该资源；</li><li>如果已经存在了，则根据YAML文件中的描述对资源进行更新。</li></ul><p>因此，在我们执行完<code>kubectl apply -f pod-demo.yaml</code>，Kubernetes将会创建一个名为<code>nginx-yaml</code>的Pod。</p><p><img src=download/Bdv52vB.png alt></p><p>类似地，<code>kubectl delete -f pod-demo.yaml</code>将会把<code>pod-demo.yaml</code>文件中定义的资源删除。</p><blockquote><p><code>apply</code>操作体现的是Kubernetes的<strong>声明式编程</strong>的思想，即，我告诉你我想要啥（我只提供一个YAML文件，即我希望最终这个Pod的样子是什么），具体怎么做由你来负责（你怎么创建Pod，怎么启动Container，是你Kubernetes的事，跟我无关）。其实，我们经常使用的SQL就有声明式编程的影子。比如一条<code>SELECT</code>语句，我们只是告诉数据库我们想查什么东西，但具体怎么查，使用哪个索引还是别的什么东西，作为用户的我们并不关系。与声明式编程相对的是命令式编程，即需要用户自己将问题拆解，告诉执行器该怎样一步步地解决问题。</p></blockquote><blockquote><p>在我们后续的学习中，几乎所有的资源都会使用YAML文件来描述。YAML在Kubernetes中使用非常广泛，因此云计算工程师又经常自嘲自己是“YAML工程师”。</p></blockquote><p><img src=download/bip6xtI.png alt></p><h2 id=label>Label
<a class=anchor href=#label>#</a></h2><p>Kubernetes支持给资源对象打标签（Label）。Pod是Kubernetes中最基本的资源对象，自然也支持打标签（Label）。</p><p>这里所说的标签，其实就是一组键值对（key-value），内容没有限制，只要key不重复，写啥都行；并且Label需要写在<code>metadata</code>里。</p><p>比如，给上一小节用到的<code>nginx-yaml</code>加上标签的话，应该是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Pod</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-yaml</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>kkk</span>: <span style=color:#ae81ff>hahaha</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>hhh</span>: <span style=color:#ae81ff>hahaha</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>kubernetes</span>: <span style=color:#ae81ff>yyds</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>  - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.14.2</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
</span></span></code></pre></div><p>上面的代码给Pod加上了三个标签，<code>kkk: hahaha</code>，<code>hhh: hahaha</code>，<code>kubernetes: yyds</code>。</p><p>我们将修改后的<code>pod-demo.yaml</code>重新<code>apply</code>一下，即可给Pod打上这三个标签：</p><p><img src=download/R83PBEH.png alt></p><p>从输出内容可以看出，<code>nginx-yaml</code>这个pod被更新了。</p><p>如何验证我们设置的标签生效了呢？可以在<code>kubectl get pod</code>的时候使用<code>-l</code>参数，例如<code>kubectl get pod -l kkk=hahaha</code>就将返回那些被打上<code>kkk: hahaha</code>标签的Pod：</p><p><img src=download/5ytuye4.png alt></p><p>可以想到，如果使用<code>kubectl get pod -l kkk=hiahiahia</code>，那将没有任何结果：</p><p><img src=download/H3GadkW.png alt></p><p>基于Label选取对应的资源，是Kubernetes中非常重要的在不同类型的资源对象间建立联系的方式。</p><h2 id=pod-controller>Pod Controller
<a class=anchor href=#pod-controller>#</a></h2><p>在介绍容器的时候我们提到过，container是脆弱的。在实际的生产环境中，container中运行的进程很可能因为各种各样的原因挂掉（比如JVM进程OOM），这时候，快速恢复业务的方法是重新启动一个新的容器实例。</p><p>另一方面，为了实现负载均衡或并行计算，我们需要维护相同的多个容器实例，来共同完成任务。</p><p>上述两方面的讨论，归结起来可以表示为：<strong>在集群中维护一定数量的容器实例</strong>。</p><p>纯粹由人工来维护一定数量的容器实例当然是可以的，但那将是十分低效和不可靠的。Kubernetes给出了一种新的解决方法——Pod Controller，来解决这一问题。</p><p>在学习Pod Controller之前，我们先来了解一下Kubernetes中的Controller机制。</p><h3 id=controller>Controller
<a class=anchor href=#controller>#</a></h3><p>在这里引用Kubernetes文档中给出的关于控制器的讨论：</p><blockquote><p>在机器人技术和自动化领域，控制回路（Control Loop）是一个非终止回路，用于调节系统状态。
这是一个控制环的例子：房间里的温度自动调节器。
当你设置了温度，告诉了温度自动调节器你的<strong>期望状态（Desired State）</strong>。 房间的实际温度是<strong>当前状态（Current State）</strong>。 通过对设备的开关控制，温度自动调节器让其当前状态接近期望状态。</p></blockquote><p><img src=download/fSz0mvd.png alt></p><p>和上述提到的“温度自动调节器”类似，Kubernetes中的控制器（Controller）将会<strong>监控当前集群中的状态，并努力使集群的当前状态满足用户设置的目标状态</strong>。</p><h3 id=pod-controller-1>Pod Controller
<a class=anchor href=#pod-controller-1>#</a></h3><p>Pod Controller，顾名思义，就是用于调节集群中当前Pod状态的Controller。下面，我们依次来介绍几种Kubernetes最常用的Pod Controller。</p><h3 id=deployment>Deployment
<a class=anchor href=#deployment>#</a></h3><p>Deployment的主要作用是努力使当前集群中的Pod数量与用户期望的状态相同。</p><p>我们先来看一个简单的Deployment的YAML定义：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>kkk</span>: <span style=color:#ae81ff>hahaha</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>kkk</span>: <span style=color:#ae81ff>hahaha</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>kubernetes</span>: <span style=color:#ae81ff>yyds</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.14.2</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
</span></span></code></pre></div><p><code>apiVersion</code>、<code>kind</code>、<code>metadata</code>都是Deployment的元信息配置，与Pod中的写法非常类似，不再赘述。</p><p><code>spec</code>中包含以下字段：</p><ul><li><code>replicas</code>：表示“副本数”。即该Deployment将会管理多少个Pod。</li><li><code>selector</code>：选择器。表示该Deployment如何在集群中查找到它需要管理的Pod。<code>matchLabels</code>表示被打上<code>kkk: hahaha</code>这个标签的Pod将会被管理。</li><li><code>template</code>中的内容想必大家都很眼熟，这其实就是我们上面提到的一个典型的Pod的描述。</li></ul><p>（可能上面的描述有点抽象，下面我们将举例说明）</p><p>将上述代码保存到本地文件中，例如<code>deployment.yaml</code>，然后执行<code>kubectl apply -f deployment.yaml</code>：</p><p><img src=download/kUrjxDv.png alt></p><p>可以看到，一个名为<code>nginx-deployment</code>的Deployment被创建了。可以使用<code>kubectl get deployment</code>查看：</p><p><img src=download/RgtWh4M.png alt></p><p>如果你得到的<code>AVAILABLE</code>的数量不是3，请耐心等一会儿。</p><p>同时，我们可以查看一下当前集群里的Pod：</p><p><img src=download/abE3SdC.png alt></p><p>可以看到，集群新启动了3个Pod，其名称前缀都是<code>nginx-deployment</code>，说明它们就是被我们刚刚创建的Deployment创建的。下面具体讨论一下这个过程是怎样发生的：</p><ol><li><code>kubectl apply -f nginx-deployment.yaml</code>在Kubernetes集群中创建了一个名为<code>nginx-deployment</code>的Deployment。</li><li>集群中的Deployment控制器发现了新创建的名为<code>nginx-deployment</code>的Deployment，然后尝试解析其中的内容。</li><li>Deployment控制器对Deployment的<code>spec.template</code>部分做hash，得到<code>pod-template-hash</code>的值，例如该值为<code>584784cc75</code>。</li><li>Deployment控制器发现这个Deployment中描述的Pod的副本数是3，并且发现选择器（<code>selector</code>）选取那些带有标签<code>kkk:hahahha</code>的Pod。于是，Deployment控制器尝试检索集群中同时带有标签<code>kkk:hahahha</code>和<code>pod-template-hash:584784cc75</code>的Pod数量，检查其是否是3个。</li><li>Deployment控制器发现上述Pod数量0，于是，根据<code>spec.template</code>中的定义创建3个Pod。</li></ol><p>我们可以尝试删除其中上述Deployment中的某一个Pod，来模拟该Pod意外崩溃的情况：</p><p><img src=download/Yo86Ns4.png alt></p><p>可以在到，在其中一个Pod被删除后（进入<code>Terminating</code>状态后），一个新的Pod立即被创建，补上了缺位。也就是说，Deployment将永远保证集群中，被打上<code>kkk:hahahha</code>和<code>pod-template-hash:584784cc75</code>标签的Pod的数量是3。</p><p><img src=download/7B5sToK.jpg alt></p><h4 id=更新deployment>更新Deployment
<a class=anchor href=#%e6%9b%b4%e6%96%b0deployment>#</a></h4><p>更新Deployment（比如更改Deployment中的副本数）非常简单，只需要编辑YAML文件，重新<code>apply</code>一下即可，例如修改<code>deployment.yaml</code>中的副本数为5：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>apps/v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-deployment</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>replicas</span>: <span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>matchLabels</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>kkk</span>: <span style=color:#ae81ff>hahaha</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>template</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>        <span style=color:#f92672>kkk</span>: <span style=color:#ae81ff>hahaha</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>kubernetes</span>: <span style=color:#ae81ff>yyds</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>containers</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>image</span>: <span style=color:#ae81ff>nginx:1.14.2</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>        - <span style=color:#f92672>containerPort</span>: <span style=color:#ae81ff>80</span>
</span></span></code></pre></div><p><code>kubectl apply -f deployment.yaml</code>之后可以发现Pod数量增加到了5：</p><p><img src=download/SoPJ5dr.png alt></p><p>当然你也可以减小<code>spec.replicas</code>的值，比如从3减小到1，这时Deployment控制器会删除多余的Pod。</p><p>总结一下，Deployment控制器的工作原理与本节开头提到的温度控制器工作原理非常相似：</p><p><img src=download/levZZB0.png alt></p><h3 id=其他pod-controller>其他Pod Controller
<a class=anchor href=#%e5%85%b6%e4%bb%96pod-controller>#</a></h3><h4 id=job>Job
<a class=anchor href=#job>#</a></h4><p>Job会创建一个或多个Pod，并确保指定数量的Pod成功终止。当Pod成功完成时，Job将追踪成功完成的情况。当达到指定的成功完成次数时，Job就完成了。删除一个Job将清除它所创建的Pod。Job一般用于定义并启动一个批处理任务。批处理任务通常并行（或串行）启动多个计算进程去处理一批工作项，处理完成后，整个批处理任务结束。</p><p>Kubernetes支持一下几种Job:</p><ul><li>非并行Job: 通常创建一个Pod直至其成功结束</li><li>固定结束次数的Job: 设置<code>.spec.completions</code>，创建多个Pod，直到<code>.spec.completions</code>个Pod成功结束</li><li>带有工作队列的并行Job: 设置<code>.spec.Parallelism</code>但不设置<code>.spec.completions</code>，当所有Pod结束并且至少一个成功时，Job就认为是成功。</li></ul><h4 id=daemonset>DaemonSet
<a class=anchor href=#daemonset>#</a></h4><p>DaemonSet用于管理在集群中每个Node上运行且仅运行一份Pod的副本实例，一般来说，在以下情形中会使用到DaemonSet：</p><ul><li>在每个Node上都运行一个存储进程</li><li>在每个Node上都运行一个日志采集程序</li><li>在每个Node上都运行一个性能监控程序</li></ul><h4 id=statefulset>StatefulSet
<a class=anchor href=#statefulset>#</a></h4><p>StatefulSet用来搭建有状态的应用集群（比如MySQL、MongoDB等）。Kubernetes会保证StatefulSet中各应用实例在创建和运行的过程中，都具有固定的身份标识和独立的后端存储；还支持在运行时对集群规模进行扩容、保障集群的高可用等功能。</p><h2 id=service>Service
<a class=anchor href=#service>#</a></h2><p>Service可以将运行在一组Pods上的应用程序公开为网络服务，简单地实现服务发现、负载均衡等功能。</p><p>k8s的Pods具有自己的生命周期，同一时刻运行的Pod集合与稍后运行的Pod集合很有可能不同（如发生更新、node故障等），Pods的IP地址可能会随时发生变化。这就会导致一个问题：如果一组后端Pods为集群内其他前端Pods提供功能，那么前端Pods该如何找出并跟踪需要连接的IP地址？通过Service，能够解耦这种关联，方便的通过Service地址访问到相应的Pods，前端不应该也没必要知道怎么访问、访问到的具体是哪一个Pod。</p><p>Service一共有4种类型：</p><ul><li>ClusterIP：通过集群的内部 IP 暴露服务，选择该值，服务只能够在集群内部可以访问，这也是默认的 <code>ServiceType</code>。</li><li>NodePort： 通过每个 Node 上的 IP 和静态端口（NodePort）暴露服务。NodePort 服务会路由到 ClusterIP 服务，这个 ClusterIP 服务会自动创建。通过请求 &lt;NodeIP>:&lt;NodePort>，可以从集群的外部访问一个 NodePort 服务。</li><li>LoadBalancer：使用云提供商的负载局衡器，可以向外部暴露服务。外部的负载均衡器可以路由到 NodePort 服务和 ClusterIP 服务。仅作了解。</li><li>ExternalName：通过返回 CNAME 和它的值，可以将服务映射到 externalName 字段的内容（例如，在集群内查找<code>my-service.my-namespace.svc</code>时，k8s DNS service只返回<code>foo.bar.example.com</code>这样的CNAME record）。没有任何类型代理被创建，网络流量发生在DNS层面。由于ExternalName要求kube-dns而我们使用的是coredns，也只作了解。</li></ul><h3 id=创建service>创建Service
<a class=anchor href=#%e5%88%9b%e5%bb%baservice>#</a></h3><p>Service通常通过selector（比如通过选取标签）来选择被访问的Pod。</p><p>继续沿用我们之前所创建的nginx-deployment。可以通过下列YAML文件创建Service (将下面的内容写入<code>service.yaml</code>)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e>#service.yaml</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>port</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>targetPort</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>anyway</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>kkk</span>: <span style=color:#ae81ff>hahaha</span>
</span></span></code></pre></div><p>注意到，我们在<code>selector</code>中使用了标签<code>kkk: hahaha</code>。</p><p>解释一下<code>spec.ports</code>中的各个字段：</p><ul><li>port：Service暴露在集群IP上的端口。集群内通过&lt;clusterIP>:&lt;port>可以访问Service。</li><li>targetPort：被代理的Pod上的端口。默认与port相同。</li><li>protocol：Service暴露出来的这个端口所支持的通信协议，通常是<code>TCP</code>或<code>UDP</code>。</li><li>name：端口名称，当Service具有多个端口时必须为每个端口提供唯一且无歧义的端口名称，具体内容写啥都行。</li></ul><p>创建Service：</p><pre tabindex=0><code>kubectl apply -f service.yaml
</code></pre><p>查看service <code>kubectl get svc</code> 或 <code>kubectl get service</code></p><p><img src=download/phOqK7i.png alt></p><p>可以看到，第二个就是我们刚才创建的service，其中，它有一个cluster-ip：<code>10.43.95.143</code>。</p><p>验证是否可以通过Service访问Pod，注意，上述这个IP是“cluster-ip”，也就是说，它是一个集群内ip，因此，只能在集群中的机器上访问：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>curl 10.43.95.143:80
</span></span></code></pre></div><p><img src=download/SSaLmz1.png alt></p><p>查看当前5个Pod的IP地址 <code>kubectl get pod -l kkk=hahaha -o wide</code></p><p><img src=download/rGP38QA.png alt></p><p>删除这5个Pod并等待Deployment重新创建<code>kubectl delete pod -l kkk=hahaha</code>。</p><p>可以看到重新创建的5个Pods的IP地址都已经发生变化：</p><p><img src=download/1xeloOy.png alt></p><p>但通过Service，仍能访问对应的Pod：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>curl 10.97.91.103:80
</span></span></code></pre></div><p><img src=download/SSaLmz1.png alt></p><h3 id=暴露端口>暴露端口
<a class=anchor href=#%e6%9a%b4%e9%9c%b2%e7%ab%af%e5%8f%a3>#</a></h3><p>之前创建的Service并没有指定类型，因此为默认的ClusterIP，只能在集群内部访问。如果需要将服务端口暴露在公网，可以使用NodePort类型。</p><p>将<code>service.yaml</code>修改为下面的内容</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e>#service.yaml</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>apiVersion</span>: <span style=color:#ae81ff>v1</span>
</span></span><span style=display:flex><span><span style=color:#f92672>kind</span>: <span style=color:#ae81ff>Service</span>
</span></span><span style=display:flex><span><span style=color:#f92672>metadata</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>name</span>: <span style=color:#ae81ff>nginx-service</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>labels</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>svc</span>: <span style=color:#ae81ff>nginx-svc</span>
</span></span><span style=display:flex><span><span style=color:#f92672>spec</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>type</span>: <span style=color:#ae81ff>NodePort</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>ports</span>:
</span></span><span style=display:flex><span>    - <span style=color:#f92672>port</span>: <span style=color:#ae81ff>80</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>nodePort</span>: <span style=color:#ae81ff>32180</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>protocol</span>: <span style=color:#ae81ff>TCP</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>name</span>: <span style=color:#ae81ff>anyway</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>selector</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>kkk</span>: <span style=color:#ae81ff>hahaha</span>
</span></span></code></pre></div><p>修改Service <code>kubectl apply -f service.yaml</code></p><p>查看service <code>kubectl get svc nginx-service</code></p><p><img src=download/YFbcSwC.png alt></p><p>此时，从集群内任一节点IP的<code>32180</code>端口均可访问到该Service指定的Pod的80端口。</p><p>比如，你现在所使用的虚拟机的IP是<code>10.251.254.183</code>，那么，你在校园网内的任何一台机器上，执行<code>curl http://10.251.254.183:32180</code>，都能得到如下的输出：</p><p><img src=download/I36tl5E.png alt></p><p>当然，你也可以使用浏览器访问：</p><p><img src=download/sRGyCgM.png alt></p><p>可以尝试删除Pods并等待新的Pods创建完成，仍可以通过上述方式访问。</p><h2 id=基于云的课程设计二选一>基于云的课程设计（二选一）
<a class=anchor href=#%e5%9f%ba%e4%ba%8e%e4%ba%91%e7%9a%84%e8%af%be%e7%a8%8b%e8%ae%be%e8%ae%a1%e4%ba%8c%e9%80%89%e4%b8%80>#</a></h2><p>注意，以下两个课程设计二选一即可。</p><h3 id=选项一云paas平台设计>选项一：云PaaS平台设计
<a class=anchor href=#%e9%80%89%e9%a1%b9%e4%b8%80%e4%ba%91paas%e5%b9%b3%e5%8f%b0%e8%ae%be%e8%ae%a1>#</a></h3><p>以上学期的云计算课程设计中设计的云PaaS平台为基础，对其中的“自动部署”功能基于Kubernetes做进一步细化。</p><p>假设有这样一个需求场景，学生针对某一门课程的某一项作业，提供了若干代码仓库地址和部署所用的配置文件；教师或助教点击“部署”按钮，云平台将会自动按照学生提供的配置文件，拉取代码仓库，进行编译、部署等操作，并返回给教师或助教一个可以访问的URL或其他形式的编译产物。</p><p>请你：</p><ol><li>设计学生所提交的配置文件格式，该配置文件应该描述如何对代码仓库进行编译（或者如何打包为镜像）、编译产物如何部署、在部署时各个组件的依赖关系等等。</li><li>结合包括但不限于架构图和顺序图等方式，结合具体案例（例如，一个简单的前后端+数据库的系统），描述你的系统是如何工作的，特别是其是如何与Kubernetes进行交互的（在这个过程中，将会创建或修改哪些Kubernetes的资源对象，包括但不限于Pod、Deployment、Service等等）。</li></ol><p>注意：仅需完成设计并编写文档即可，<strong>不需要编码实现</strong>。</p><h3 id=选项二数据分析开发环境迁移上云>选项二：“数据分析开发环境”迁移上云
<a class=anchor href=#%e9%80%89%e9%a1%b9%e4%ba%8c%e6%95%b0%e6%8d%ae%e5%88%86%e6%9e%90%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83%e8%bf%81%e7%a7%bb%e4%b8%8a%e4%ba%91>#</a></h3><p>在数据分析实验中，在本地部署Hadoop开发环境是繁琐的，并且很容易出错，因此，可以尝试将本次课程实践中的“数据分析开发环境”的部署迁移到Kubernetes上。</p><p>请你：</p><ol><li>设计并编写一系列YAML文件，这些YAML文件包含在Kubernetes中部署“数据分析开发环境”的各类Pod、Deployment、Service等的定义。用户使用kubectl将这些文件apply到Kubernetes集群中，即可完成对“数据分析开发环境”的部署，从而可以直接在Kubernetes中完成数据分析工作。</li><li>提供说明，用户应该如何使用你的YAML文件，从而在Kubernetes中完成“数据分析开发环境”的部署；并且在部署完成后，用户应该如何使用该“数据分析开发环境”进行数据分析工作。</li></ol><h4 id=hint>Hint
<a class=anchor href=#hint>#</a></h4><p>在启动Hive容器时，可以直接使用已经云平台已有的Hive镜像 <code>scs.buaa.edu.cn:8081/iobs/hive:1.0.0</code>，其Dockerfile是：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> openjdk:8-bullseye</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> mkdir -p /export/server <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    wget https://mirror.tuna.tsinghua.edu.cn/apache/hive/hive-3.1.2/apache-hive-3.1.2-bin.tar.gz <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    tar -xvf apache-hive-3.1.2-bin.tar.gz -C /export/server <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    rm -rf apache-hive-3.1.2-bin.tar.gz<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> HIVE_HOME<span style=color:#f92672>=</span>/export/server/apache-hive-3.1.2-bin<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENV</span> PATH<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;</span><span style=color:#e6db74>${</span>PATH<span style=color:#e6db74>}</span><span style=color:#e6db74>:</span><span style=color:#e6db74>${</span>HIVE_HOME<span style=color:#e6db74>}</span><span style=color:#e6db74>/bin&#34;</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> wget https://mirrors.tuna.tsinghua.edu.cn/apache/hadoop/common/hadoop-3.3.4/hadoop-3.3.4.tar.gz <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    tar -xvf hadoop-3.3.4.tar.gz -C /export/server <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    rm hadoop-3.3.4.tar.gz<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> cp <span style=color:#e6db74>${</span>HIVE_HOME<span style=color:#e6db74>}</span>/conf/hive-env.sh.template <span style=color:#e6db74>${</span>HIVE_HOME<span style=color:#e6db74>}</span>/conf/hive-env.sh <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    echo <span style=color:#e6db74>&#34;export HADOOP_HOME=/export/server/hadoop-3.3.4&#34;</span> &gt;&gt; <span style=color:#e6db74>${</span>HIVE_HOME<span style=color:#e6db74>}</span>/conf/hive-env.sh <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    echo <span style=color:#e6db74>&#34;export HADOOP_CONF_DIR=/export/server/hadoop-3.3.4/etc/hadoop&#34;</span> &gt;&gt; <span style=color:#e6db74>${</span>HIVE_HOME<span style=color:#e6db74>}</span>/conf/hive-env.sh <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    echo <span style=color:#e6db74>&#34;export HIVE_CONF_DIR=</span><span style=color:#e6db74>${</span>HIVE_HOME<span style=color:#e6db74>}</span><span style=color:#e6db74>/conf&#34;</span> &gt;&gt; <span style=color:#e6db74>${</span>HIVE_HOME<span style=color:#e6db74>}</span>/conf/hive-env.sh <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    echo <span style=color:#e6db74>&#34;export HIVE_AUX_JARS_PATH=</span><span style=color:#e6db74>${</span>HIVE_HOME<span style=color:#e6db74>}</span><span style=color:#e6db74>/lib&#34;</span> &gt;&gt; <span style=color:#e6db74>${</span>HIVE_HOME<span style=color:#e6db74>}</span>/conf/hive-env.sh <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    echo <span style=color:#e6db74>&#34;export HIVE_LOG_DIR=</span><span style=color:#e6db74>${</span>HIVE_HOME<span style=color:#e6db74>}</span><span style=color:#e6db74>/logs&#34;</span> &gt;&gt; <span style=color:#e6db74>${</span>HIVE_HOME<span style=color:#e6db74>}</span>/conf/hive-env.sh<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> wget https://mirrors.tuna.tsinghua.edu.cn/mysql/downloads/Connector-J/mysql-connector-java-8.0.29.tar.gz <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    tar -xvf mysql-connector-java-8.0.29.tar.gz <span style=color:#f92672>&amp;&amp;</span> <span style=color:#ae81ff>\
</span></span></span><span style=display:flex><span><span style=color:#ae81ff></span>    cp mysql-connector-java-8.0.29/mysql-connector-java-8.0.29.jar <span style=color:#e6db74>${</span>HIVE_HOME<span style=color:#e6db74>}</span>/lib<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>RUN</span> mkdir -p /data/hive<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>EXPOSE</span><span style=color:#e6db74> 10000</span><span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/commit/85934d4b10cd0ce3e797c49b9cb624f8bf5b0e04 title='Last modified by loheagn | October 29, 2022' target=_blank rel=noopener><img src=/doc/svg/calendar.svg class=book-icon alt=Calendar>
<span>October 29, 2022</span></a></div><div><a class="flex align-center" href=https://github.com/alex-shpak/hugo-book/edit/main/exampleSite/content/cloud-labs/cloud/kube-single-3/index.md target=_blank rel=noopener><img src=/doc/svg/edit.svg class=book-icon alt=Edit>
<span>Edit this page</span></a></div></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#kubernetes综合实验>Kubernetes综合实验</a><ul><li><a href=#实验目的>实验目的</a></li><li><a href=#背景>背景</a></li><li><a href=#初识kubernetes>初识Kubernetes</a><ul><li><a href=#kubernetes简介>Kubernetes简介</a></li><li><a href=#创建kubernetes集群>创建Kubernetes集群</a></li><li><a href=#使用kubernetes启动第一个容器>使用Kubernetes启动第一个容器</a></li></ul></li><li><a href=#pod>Pod</a><ul><li><a href=#查看pod>查看Pod</a></li><li><a href=#删除pod>删除Pod</a></li><li><a href=#pod的生命周期>Pod的生命周期</a></li><li><a href=#使用yaml文件管理pod>使用YAML文件管理Pod</a></li></ul></li><li><a href=#label>Label</a></li><li><a href=#pod-controller>Pod Controller</a><ul><li><a href=#controller>Controller</a></li><li><a href=#pod-controller-1>Pod Controller</a></li><li><a href=#deployment>Deployment</a></li><li><a href=#其他pod-controller>其他Pod Controller</a></li></ul></li><li><a href=#service>Service</a><ul><li><a href=#创建service>创建Service</a></li><li><a href=#暴露端口>暴露端口</a></li></ul></li><li><a href=#基于云的课程设计二选一>基于云的课程设计（二选一）</a><ul><li><a href=#选项一云paas平台设计>选项一：云PaaS平台设计</a></li><li><a href=#选项二数据分析开发环境迁移上云>选项二：“数据分析开发环境”迁移上云</a></li></ul></li></ul></li></ul></nav></div></aside></main></body></html>